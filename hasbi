#!/usr/bin/env ruby
#:cal SetSyn("Ruby")

# Set process name
$0 = "hasbi"

require 'bundler'
Bundler.require

class WebViewWindow
    attr_accessor :window, :screen, :webview
    def initialize
        @window = Gtk::Window.new :toplevel
        @window.set_type_hint 6
        @window.set_decorated false
        @screen = @window.get_screen
        @webview = WebKit::WebView.new
        @scroll = Gtk::ScrolledWindow.new nil, nil
        @window.add @scroll
        @scroll.add @webview
        GObject.signal_connect(@window, "destroy") { Gtk.main_quit }
        #transparent
        post_init
    end
    # TODO: This doesn't work and I don't know why.
    def transparent
        visual = @screen.get_rgba_visual()
        @window.set_visual visual
        @scroll.set_visual visual
        @webview.set_transparent true
    end
    def erb path
        erb = Erubis::Eruby.new(File.read("views/#{path.to_s}.erb"))
        result = erb.result(binding())
        @window.show_all
        @webview.load_html_string(result, "file://#{File.absolute_path("./web/#{path.to_s}")}")
    end
    def post_init
    end
end

class StartMenu < WebViewWindow
    def post_init
        @window.resize @screen.get_width, @screen.get_height
        @window.maximize
        erb :index
    end
end

def init
    # Setup window
    GirFFI.setup :WebKit, '3.0'
    Gtk.init
    $app_info = []
    get_applications
    $startmenu = StartMenu.new
end
def get_applications
    $app_info = []
    Dir.glob('/usr/share/applications/*.desktop').each do |app|
        if File.file? app
            text = File.open(app).read
            data = {}
            icon_theme = Gtk::IconTheme.get_default
            lines = text.split("\n")
            lines.each do |line|
                bits = line.split("=")
                if bits.length>1
                    if bits[0]=="Name" or bits[0]=="Exec" or bits[0]=="Comment"
                        data[bits[0]]=bits[1]
                    elsif bits[0]=="Icon"
                        if bits[1][0]=='/'
                            data[bits[0]]=bits[1]
                        else
                            icon_name = bits[1].split('.')[0]
                            if icon_theme.has_icon icon_name
                                data[bits[0]]= icon_theme.lookup_icon(icon_name,64,0).get_filename.read_string
                            elsif icon_theme.has_icon bits[1]
                                data[bits[0]]= icon_theme.lookup_icon(bits[1],64,0).get_filename.read_string
                            else
                                puts "[ERROR::NO_ICON] #{icon_name}, #{bits[1]}"
                            end

                            #data[bits[0]]=`find {/usr/share/icons,/usr/share/pixmaps} -iname "#{bits[1]}"`.strip
                        end
                    end
                end
            end
            $app_info << data
        end
    end
    $app_info.sort! do |a,b|
        a["Name"].downcase <=> b["Name"].downcase
    end
end

def get_name_bits
    full = GLib.get_real_name
    bits = full.split ' '
    first = bits[0]
    last = bits[1..-1].join ' '
    return [first,last]
end

init
EM::run do
    $loading = true
    give_tick = proc { 
        Gtk::main_iteration; EM.next_tick(give_tick)
    }
    give_tick.call
    # Start Websocket
    EM::WebSocket.start(:host => "0.0.0.0", :port => 38473) do |ws|
        ws.onopen { |handshake|
            puts "WebSocket connection open"

            # Access properties on the EM::WebSocket::Handshake object, e.g.
            # path, query_string, origin, headers
        }
        ws.onclose { puts "Connection closed" }
        ws.onmessage { |msg|
            puts "Recieved command: #{msg}"
            ws.send(MultiJson.dump(eval(msg)))
        }
    end
end
